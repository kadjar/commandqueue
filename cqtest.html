<html>
<head>
	<script src="http://cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
</head>
	<body>
		<button id="add">Add</button>
		<button id="start">Start</button>

		<ul id="log"></ul>

		<h1 id="complete"></h1>

<script>
	
var CommandQueue;

/* Simple JavaScript Inheritance
 * By John Resig http://ejohn.org/
 * MIT Licensed.
 */
// Inspired by base2 and Prototype
(function(){
  var initializing = false, fnTest = /xyz/.test(function(){xyz;}) ? /\b_super\b/ : /.*/;
 
  // The base Class implementation (does nothing)
  this.Class = function(){};
 
  // Create a new Class that inherits from this class
  Class.extend = function(prop) {
    var _super = this.prototype;
   
    // Instantiate a base class (but only create the instance,
    // don't run the init constructor)
    initializing = true;
    var prototype = new this();
    initializing = false;
   
    // Copy the properties over onto the new prototype
    for (var name in prop) {
      // Check if we're overwriting an existing function
      prototype[name] = typeof prop[name] == "function" &&
        typeof _super[name] == "function" && fnTest.test(prop[name]) ?
        (function(name, fn){
          return function() {
            var tmp = this._super;
           
            // Add a new ._super() method that is the same method
            // but on the super-class
            this._super = _super[name];
           
            // The method only need to be bound temporarily, so we
            // remove it when we're done executing
            var ret = fn.apply(this, arguments);        
            this._super = tmp;
           
            return ret;
          };
        })(name, prop[name]) :
        prop[name];
    }
   
    // The dummy class constructor
    function Class() {
      // All construction is actually done in the init method
      if ( !initializing && this.init )
        this.init.apply(this, arguments);
    }
   
    // Populate our constructed prototype object
    Class.prototype = prototype;
   
    // Enforce the constructor to be what we expect
    Class.prototype.constructor = Class;
 
    // And make this class extendable
    Class.extend = arguments.callee;
   
    return Class;
  };
})();

(function() {

    Command = Class.extend({
        init: function (method, args, context) {
            // method, args, context
            this.method = method;
            this.args = args;
            this.context = context;
        }
    });

	CommandQueue = Class.extend({        
        firstCommand: null,
        startCmd: null
	});	
	var CQ = CommandQueue.prototype;	

    var lastPromise = null;    

    CQ.start = function() {
        this.startCmd();
        // var startCmd = new Command(function (complete) { complete() }, [], this)
        // this.addCommand(startCmd, true);
    }   
    
    CQ.addCommand = function(cmd) {
        // var self = this;      
        // if (!this.firstCommand) {         
        //     this.firstCommand = true;
        //     console.log('adding first command')

        //     this.addCommand(new Command(function (complete) { self.startCmd = complete }, [], this) );
        //     this.addCommand(cmd);

        //     return;
        // }
        console.log('adding command');

    	var method = cmd.method;
    	var args = cmd.args;
    	var context = cmd.context;

        var methodDeferred = $.Deferred();
        var queueDeferred = this.setup();       

        // execute next queue method
        queueDeferred.done(function() {

            // call actual method and wrap output in deferred
            args = (Object.prototype.toString.apply(args) === '[object Array]') ? args : [args];
            args.push(methodDeferred.resolve);
            
            method.apply(context, args);
        });
        lastPromise = methodDeferred.promise();
    };

    CQ.setup = function() {
        var queueDeferred = $.Deferred();

        // when the previous method returns, resolve this one
        $.when(lastPromise).done(function() {
            console.log('executing command');
            queueDeferred.resolve();
        });

        return queueDeferred.promise();
    }

    CQ.clear = function () {
        this.firstCommand = null;
        this.startCmd = null;
    }

})();

//$(document).ready(function() {
	var cq = new CommandQueue();
	var count = 0;
	var ctxt = this;

	$('#add').on('click', function () {
		var cmd = cq.addCommand(new Command(log, count, ctxt));

		count++;
	})

    $('#start').on('click', function() {
        cq.start();        
    })

	function log(i, complete) {
		$('#log').append($('<li></li>').text('logged item ' +i));
		setTimeout(function() {
			complete();
		}, 2000);
	}
//});
</script>

var queue = function() {
    this.stack = [];
}

queue.prototype.start = function() {
    console.log('start');
    var funct = this.stack.pop();
    var self = this;    
    if (funct) {
        funct.call().then(function() { self.start(); });
    }
}

queue.prototype.add = function(cmd) {
    this.stack.unshift(cmd);   
}

var cmd = function() {
    this.work = function() {
        var deferred = new $.Deferred();
        
        setTimeout(function() {
           console.log('yay, i workde');
           deferred.resolve();
        }, 2000);
        return deferred.promise();
    }
}

var q = new queue();

q.add(new cmd().work);
q.add(new cmd().work);
q.add(new cmd().work);
q.add(new cmd().work);
q.add(new cmd().work);
q.add(new cmd().work);
q.add(new cmd().work);
q.add(new cmd().work);
q.add(new cmd().work);
q.add(new cmd().work);
q.add(new cmd().work);
q.add(new cmd().work);
q.add(new cmd().work);
q.add(new cmd().work);
q.add(new cmd().work);
q.add(new cmd().work);
q.add(new cmd().work);

q.start();




	</body>
</html>