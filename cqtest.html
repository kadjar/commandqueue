<html>
<head>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
</head>
    <body>
        <button id="add">Add</button>
        <button id="start">Start</button>

        <ul id="log"></ul>

        <h1 id="complete"></h1>

<script>
    
var CommandQueue;

/* Simple JavaScript Inheritance
 * By John Resig http://ejohn.org/
 * MIT Licensed.
 */
// Inspired by base2 and Prototype
(function(){
  var initializing = false, fnTest = /xyz/.test(function(){xyz;}) ? /\b_super\b/ : /.*/;
 
  // The base Class implementation (does nothing)
  this.Class = function(){};
 
  // Create a new Class that inherits from this class
  Class.extend = function(prop) {
    var _super = this.prototype;
   
    // Instantiate a base class (but only create the instance,
    // don't run the init constructor)
    initializing = true;
    var prototype = new this();
    initializing = false;
   
    // Copy the properties over onto the new prototype
    for (var name in prop) {
      // Check if we're overwriting an existing function
      prototype[name] = typeof prop[name] == "function" &&
        typeof _super[name] == "function" && fnTest.test(prop[name]) ?
        (function(name, fn){
          return function() {
            var tmp = this._super;
           
            // Add a new ._super() method that is the same method
            // but on the super-class
            this._super = _super[name];
           
            // The method only need to be bound temporarily, so we
            // remove it when we're done executing
            var ret = fn.apply(this, arguments);        
            this._super = tmp;
           
            return ret;
          };
        })(name, prop[name]) :
        prop[name];
    }
   
    // The dummy class constructor
    function Class() {
      // All construction is actually done in the init method
      if ( !initializing && this.init )
        this.init.apply(this, arguments);
    }
   
    // Populate our constructed prototype object
    Class.prototype = prototype;
   
    // Enforce the constructor to be what we expect
    Class.prototype.constructor = Class;
 
    // And make this class extendable
    Class.extend = arguments.callee;
   
    return Class;
  };
})();

(function() {

    Command = Class.extend({
        init: function (ctxt, method, args) {
            this.ctxt = ctxt;
            this.method = method;
            this.args = args;
        }
    })

    CommandQueue = Class.extend({
        stack: [],
        running: false
    });
    var CQ = CommandQueue.prototype;

    CQ.start = function() {
        
        var cmd = this.stack.pop();
        var self = this;    
        
        this.running == false && console.group('start');
        
        if (cmd) {
            this.running = true;
            this._runCommand(cmd).then(function() { self.start(); });
        }
        else {
            this.running = false;
            console.warn('stop');
        }
    }

    CQ.add = function(cmd) {
        this.stack.unshift(cmd);   
    }

    CQ._runCommand = function(cmd) {
        var deferred = new $.Deferred();

        cmd.args = (Object.prototype.toString.apply(cmd.args) === '[object Array]') ? cmd.args : [cmd.args];
        cmd.args.push(deferred.resolve);

        cmd.method.apply(cmd.context, cmd.args)

        return deferred.promise();
    }

})();

    var cq = new CommandQueue();
    var count = 0;
    var ctxt = this;

    $('#add').on('click', function () {
        var cmd = cq.add(new Command(ctxt, log, count));

        count++;
    })

    $('#start').on('click', function() {
        cq.start();        
    })

    function log(i, complete) {       
        setTimeout(function() {
            $('#log').append($('<li></li>').text('logged item ' +i));
            complete();
        }, 2000);
    }
</script>



    </body>
</html>